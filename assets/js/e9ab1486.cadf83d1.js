"use strict";(self.webpackChunkxcpdoc=self.webpackChunkxcpdoc||[]).push([[549],{7232:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var n=s(4848),a=s(8453);const o={},i="UTXO Support",r={id:"advanced/specifications/utxo-support",title:"UTXO Support",description:'With Ordinals, a user who does not own an Ordinal cannot create a valid Bitcoin transaction to move an Ordinal that is not in their wallet. This is because the user must possess the UTXO that holds the "sat". Unlike Ordinals, Counterparty as a metaprotcol is entirely detached from Layer-1 consensus rules\u2014this allows Counterparty to be much more versatile and extendable. However, Ordinals, given its large community, offers Counterparty asset owners the opportunity to benefit from greater liquidity and a larger ecosystem generally. For this it is necessary to be able to attach and detach Counterparty assets to/from UTXOs. This will allow Counterparty assets to be compliant with the Ordinals trading transactional structure, allowing the large players in the Ordinals ecosystem to seamlessly integrate with Counterparty assets.',source:"@site/docs/advanced/specifications/utxo-support.md",sourceDirName:"advanced/specifications",slug:"/advanced/specifications/utxo-support",permalink:"/docs/advanced/specifications/utxo-support",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/advanced/specifications/utxo-support.md",tags:[],version:"current",frontMatter:{},sidebar:"advanced",previous:{title:"Subassets on Numeric Assets",permalink:"/docs/advanced/specifications/allow-subassets-on-numerics"},next:{title:"Gas System",permalink:"/docs/advanced/specifications/gas-system"}},c={},d=[{value:"Considerations",id:"considerations",level:2},{value:"API Changes",id:"api-changes",level:2},{value:"Database Changes",id:"database-changes",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"utxo-support",children:"UTXO Support"}),"\n",(0,n.jsx)(t.h1,{id:"motivations",children:"Motivations"}),"\n",(0,n.jsxs)(t.p,{children:['With Ordinals, a user who does not own an Ordinal cannot create a valid Bitcoin transaction to move an Ordinal that is not in their wallet. This is because the user must possess the UTXO that holds the "sat". Unlike Ordinals, Counterparty as a metaprotcol is entirely detached from Layer-1 consensus rules\u2014this allows Counterparty to be much more versatile and extendable. However, Ordinals, given its large community, offers Counterparty asset owners the opportunity to benefit from greater liquidity and a larger ecosystem generally. For this it is necessary to be able to ',(0,n.jsx)(t.strong,{children:"attach and detach Counterparty assets to/from UTXOs"}),". This will allow Counterparty assets to be compliant with the Ordinals trading transactional structure, allowing the large players in the Ordinals ecosystem to seamlessly integrate with Counterparty assets."]}),"\n",(0,n.jsx)(t.h1,{id:"design",children:"Design"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"balances"}),", ",(0,n.jsx)(t.code,{children:"credits"})," and ",(0,n.jsx)(t.code,{children:"debits"})," tables, as well as the ",(0,n.jsx)(t.code,{children:"ledger.credit()"})," and ",(0,n.jsx)(t.code,{children:"ledger.debit()"})," functions will be modified to be able to support balances attached to UTXOs."]}),"\n",(0,n.jsxs)(t.p,{children:["A new contract ",(0,n.jsx)(t.code,{children:"utxo.py"})," will allow you to attach and detach assets from a UTXO. This new contract will be similar to a classic ",(0,n.jsx)(t.code,{children:"send"})," except that the source and destination will be integrated into the data embedded in the transaction."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"get_tx_info()"})," function will be modified to also return inputs with attached assets as well as the first non-OP_RETRUN output."]}),"\n",(0,n.jsxs)(t.p,{children:["The inputs and output returned by ",(0,n.jsx)(t.code,{children:"get_tx_info()"})," will be stored in the ",(0,n.jsx)(t.code,{children:"utxos_info"})," field of the ",(0,n.jsx)(t.code,{children:"transactions"}),"  table by the ",(0,n.jsx)(t.code,{children:"list_tx()"})," function."]}),"\n",(0,n.jsxs)(t.p,{children:["Then the ",(0,n.jsx)(t.code,{children:"parse_tx()"})," function will check that the ",(0,n.jsx)(t.code,{children:"utxos_info"})," field contains entries and if so will pass them to the ",(0,n.jsx)(t.code,{children:"utxo.move_assets()"})," function."]}),"\n",(0,n.jsxs)(t.p,{children:["Here is the signature of the ",(0,n.jsx)(t.code,{children:"utxo.compose()"})," function:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'def compose(db, source, destination, asset, quantity):\n    """\n    Compose a UTXO message.\n    source: the source address or UTXO\n    destination: the destination address or UTXO\n    asset: the asset to transfer\n    quantity: the quantity to transfer\n    """\n'})}),"\n",(0,n.jsx)(t.p,{children:"For convenience, two functions, as well as two distinct routes, will be made available:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'"/v2/addresses/<address>/compose/attach": transaction.compose_attach,\n"/v2/utxos/<utxo>/compose/detach": transaction.compose_detach,\n'})}),"\n",(0,n.jsx)(t.h2,{id:"considerations",children:"Considerations"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["It is possible to attach and detach an arbitrary number of assets from an address or UTXO, however when a UTXO is used in a transaction, all assets attached to that UTXO are moved to the first UTXO non- ",(0,n.jsx)(t.code,{children:"OP_RETURN"})," output of the transaction."]}),"\n",(0,n.jsxs)(t.li,{children:["Fees in XCP, calculated using the ",(0,n.jsx)(t.a,{href:"https://gist.github.com/adamkrellenstein/7c7cab257cee162233fc2ba6682eb8da",children:"new Gas system"}),", will be paid by the source address for an ",(0,n.jsx)(t.code,{children:"attach"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"utxo.move_assets()"})," is executed before Counterparty contracts. This means that if a UTXO with attached assets is used for a Counterparty transaction, the assets are first moved and then the Counterparty transaction executed."]}),"\n",(0,n.jsxs)(t.li,{children:["To avoid problems due to (3), a new parameter ",(0,n.jsx)(t.code,{children:"exclude_utxos"})," will be added to all transaction composition functions."]}),"\n",(0,n.jsxs)(t.li,{children:["For each ",(0,n.jsx)(t.code,{children:"attach"})," and ",(0,n.jsx)(t.code,{children:"detach"}),", a row will be added to the ",(0,n.jsx)(t.code,{children:"send"})," table, triggering the ",(0,n.jsx)(t.code,{children:"ATTACH_TO_UTXO"})," and ",(0,n.jsx)(t.code,{children:"DETACH_FROM_UTXO"})," events respectively."]}),"\n",(0,n.jsxs)(t.li,{children:["When a UTXO is spent, a row is added to the ",(0,n.jsx)(t.code,{children:"send"})," table for each asset attached to this UTXO, triggering a ",(0,n.jsx)(t.code,{children:"UTXO_MOVE"})," event."]}),"\n",(0,n.jsxs)(t.li,{children:["When assets are attached to a UTXO, it is impossible to use them for a Counterparty transaction (",(0,n.jsx)(t.code,{children:"order"}),", ",(0,n.jsx)(t.code,{children:"send"}),", etc.) apart from ",(0,n.jsx)(t.code,{children:"detach"}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"api-changes",children:"API Changes"}),"\n",(0,n.jsx)(t.p,{children:"Three new routes will be added:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'"/v2/addresses/<address>/compose/attach": transaction.compose_attach,\n"/v2/utxos/<utxo>/compose/detach": transaction.compose_detach,\n"/v2/utxos/<utxo>/compose/movetoutxo": transaction.compose_movetoutxo,\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Balances will now contain an additional ",(0,n.jsx)(t.code,{children:"utxo"})," field."]}),"\n",(0,n.jsx)(t.h2,{id:"database-changes",children:"Database Changes"}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"utxo"})," field will be added to the ",(0,n.jsx)(t.code,{children:"credits"}),", ",(0,n.jsx)(t.code,{children:"debits"})," and ",(0,n.jsx)(t.code,{children:"balances"})," tables. One of the two fields, ",(0,n.jsx)(t.code,{children:"address"})," or ",(0,n.jsx)(t.code,{children:"utxo"})," will be null. The format of the ",(0,n.jsx)(t.code,{children:"utxo"})," field is ",(0,n.jsx)(t.code,{children:"<tx_hash>:<n>"})," ."]}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"utxos_info"})," field will be added to the ",(0,n.jsx)(t.code,{children:"transactions"})," table. This field will contain a list of UTXOs separated by spaces. The last in the list is the first non-",(0,n.jsx)(t.code,{children:"OP_RETURN"})," output of the transaction, and the previous ones, if present, are the transaction inputs with assets attached. If there is more than one, that means we need to move all the assets of the first(s) UTXO(s) to the last one."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>r});var n=s(6540);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);