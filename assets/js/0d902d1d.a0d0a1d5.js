"use strict";(self.webpackChunkxcpdoc=self.webpackChunkxcpdoc||[]).push([[313],{4318:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=t(4848),a=t(8453);const i={},o="Require Dispenser to be Source Address",r={id:"advanced/specifications/dispenser-must-be-created-by-source",title:"Require Dispenser to be Source Address",description:"For an unknown reason, it has always been possible to open a dispenser on an address that you yourself do not own. Of course, this is a major security vulnerability as it can allow anyone on the network to force other users to sell assets without their consent (potentially with major legal consequences). Generally speaking, this is just a Bad Idea(TM).",source:"@site/docs/advanced/specifications/dispenser-must-be-created-by-source.md",sourceDirName:"advanced/specifications",slug:"/advanced/specifications/dispenser-must-be-created-by-source",permalink:"/docs/advanced/specifications/dispenser-must-be-created-by-source",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/advanced/specifications/dispenser-must-be-created-by-source.md",tags:[],version:"current",frontMatter:{},sidebar:"advanced",previous:{title:"Make Dispenses Normal Counterparty Transactions",permalink:"/docs/advanced/specifications/enable-dispense-tx"},next:{title:"Fair Minting",permalink:"/docs/advanced/specifications/fairminter"}},c={},d=[{value:"API Changes",id:"api-changes",level:2},{value:"Database Changes",id:"database-changes",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"require-dispenser-to-be-source-address",children:["Require Dispenser to be ",(0,s.jsx)(n.code,{children:"Source"})," Address"]}),"\n",(0,s.jsx)(n.h1,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(n.p,{children:"For an unknown reason, it has always been possible to open a dispenser on an address that you yourself do not own. Of course, this is a major security vulnerability as it can allow anyone on the network to force other users to sell assets without their consent (potentially with major legal consequences). Generally speaking, this is just a Bad Idea(TM)."}),"\n",(0,s.jsxs)(n.p,{children:['A hacky workaround was implemented in November 2023 (with the unhelpful ChangeLog entry "Redefined EMPTY address to mean no XCP or BTC history\u201d) which prevents dispensers from being opened on any address that has any XCP or BTC history. This probably resolves the security issue but ',(0,s.jsx)(n.a,{href:"https://github.com/CounterpartyXCP/counterparty-core/pull/1255/files#diff-446a2aa52fd57fd6379f4732ae36f794df6f0fb1585494f798f4aa3f7b94fca2R136",children:"that little patch"})," unintentionally (and retroactively!) made the entirety of AddrIndexRs (and its ~200GB database) consensus-critical and mandatory for parsing. AddrIndexRs is a broken, unmaintained fork of a third-party codebase that is\xa0",(0,s.jsx)(n.em,{children:"not"}),"\xa0deterministic and has been the cause of a ",(0,s.jsx)(n.a,{href:"https://github.com/CounterpartyXCP/counterparty-core/issues?q=is%3Aissue+addrindexrs+label%3Abug+",children:"large number of critical bugs in Counterparty"}),", not to mention the fact that it makes Counterparty deployment a total PITA. Thankfully, once this protocol change goes into effect, we can kill AddrIndexRs, per\xa0",(0,s.jsx)(n.a,{href:"https://github.com/CounterpartyXCP/counterparty-core/issues/1764",children:"#1764"}),"."]}),"\n",(0,s.jsx)(n.h1,{id:"design",children:"Design"}),"\n",(0,s.jsxs)(n.p,{children:["The implementation is straightforward, quick, and already done here: ",(0,s.jsx)(n.a,{href:"https://github.com/CounterpartyXCP/counterparty-core/pull/1792",children:"https://github.com/CounterpartyXCP/counterparty-core/pull/1792"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["A protocol change will be added ",(0,s.jsx)(n.code,{children:"dispenser_must_be_created_by_source"})," to the ",(0,s.jsx)(n.code,{children:"protocol_changes.json"})," file. From this block onwards, the ",(0,s.jsx)(n.code,{children:"compose.validate"})," function will verify that ",(0,s.jsx)(n.code,{children:"source == open_address"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The only known downside to this change is that it will require a moving tokens to a wallet (e.g. a cold wallet) before using that wallet as a dispenser. (By differentiating between ",(0,s.jsx)(n.code,{children:"source"})," and ",(0,s.jsx)(n.code,{children:"origin"}),"  you can simulate Ordinals-like fair minting; but we\u2019re going to be implementing an ",(0,s.jsx)(n.em,{children:"actual"})," ",(0,s.jsx)(n.a,{href:"https://www.notion.so/Fair-Minting-17033d5385ab4a61808dbf31ea33daf9?pvs=21",children:"Fair Minting"})," contract, so no functionality will be lost.)"]}),"\n",(0,s.jsx)(n.h2,{id:"api-changes",children:"API Changes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"No API changes"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"database-changes",children:"Database Changes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"No database changes"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);